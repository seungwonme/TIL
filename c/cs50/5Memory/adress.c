// https://www.boostcourse.org/cs112/lecture/119028
// pointer 개념 명강의... 박수 짝짝

#include <stdio.h>

int main(void)
{
  int n = 50;
  // & : ~의 주소를 줘 (변수의 메모리상 주소 받기)
  // * : 그 주소로 가줘 (메모리 주소의 실제값 얻기)
  // %p : pointer 16진수 표현 형식지정자

  printf("%i\n", *&n); // 50
  // *과 &은 서로 반대의 정의를 갖고 있으므로 둘 다 사용하면 처음 값이 된다.

  printf("%p\n", &n); // 0x로 시작하는 16진수 n의 메모리 주소가 나온다.

  // pointer 만들기
  int *p = &n;
  // Int형 값의 주소를 가리키는 pointer 변수 p를 만들었다.
  // 변수에 주소를 저장하고 싶다면 그 변수의 자료형뿐만 아니라 *도 사용해야한다. 그리고 그 변수를 포인터라고 한다.

  // 만약 int p = &n; 처럼 *없이 포인터 변수를 생성하려고 하면 clang 컴파일러가 경고를 한다. 주소를 저장하려고하기 때문이다.
  // int 변수이름 -> 정수형의 변수를 만들어주세요.
  // int *변수이름 -> 정수형의 값을 가진 변수의 주소값을 담을 변수를 만들어주세요.
  // int는 정수형인데 주소는 16진수이므로 주소는 반드시 포인터에 저장해야한다.

  printf("%p\n", p); // n의 메모리 주소
  // *은 선언 시에만 붙인다.
  printf("%i\n", *p); // 50

  printf("%p\n", &p); // 0x로 시작하는 16진수 pointer 변수 p의 메모리 주소가 나온다.

  // 내가 헷갈린 이유 : &n은 주소고 *p는 주소의 값을 표현하는 건데?
  // 이 맥락에서 헷갈렸다. int* (정수형 변수을 가리키는 포인터 변수 선언), p(변수의 이름)라고 따로 생각하자

  printf("-------------\n");

  char *s = "EMMA";
  // s는 문자형 값을 가리키는 포인터 변수이며 "EMMA"의 첫 글자 즉. 'E'의 메모리 주소값을 지닌다.
  // 포인터변수 s는 s[0](문자)의 메모리 주소와 같다. 즉, s = &s[0];
  printf("%c\n", *s); // *s -> s는 메모리 주소를 가지고 있음, *은 그 주소로 가달라고 함 => s[0]의 값 'E'
  printf("%c\n",*(s+1));
  printf("%c\n",*(s+2));
  printf("%c\n",*(s+3));
  // []는 syntax sugar(구문 설탕)이라고 한다. s[1] -> *(s+1) 컴퓨터 내부에서 바꿔준다.

  printf("%s\n", s);
  printf("%p\n", s);
  // s는 문자열 "EMMA"의 첫 글자 'E'의 메모리 주소를 담고 있는 포인터인데 서식지정자 %s와 만나면 문자열을 출력한다.

  printf("%p\n", &s[0]); // s = &s[0]
  printf("%p\n", &s[1]);
  printf("%p\n", &s[2]);
  printf("%p\n", &s[3]);
  printf("%p\n", &s[4]);
  printf("%i\n", s[4]); // 0
  // 문자열은 문자들의 배열이며, 각 문자들의 주소는 1바이트 차이로 연결되어있다.
  // 문자열은 문자의 개수 + 1 바이트 만큼의 메모리 공간이 필요하고 마지막 바이트에는 컴퓨터에게 문자열의 마지막임을 표시하는 '\0'가 들어간다.
  // 문자열은 변수가 가지고 있는 메모리 주소로부터 시작해서 마지막을 나타내는 '\0'가 나올지때까지 루프를 돌려서 만들어진다.

  return 0;
}